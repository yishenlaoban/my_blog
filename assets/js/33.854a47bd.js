(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{569:function(t,e,a){"use strict";a.r(e);var s=a(3),v=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"十、持久化-rdb"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十、持久化-rdb"}},[t._v("#")]),t._v(" 十、持久化—RDB")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220212182918993.png",alt:"image-20220212182918993"}})]),t._v(" "),a("h3",{attrs:{id:"什么是rdb"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是rdb"}},[t._v("#")]),t._v(" 什么是RDB")]),t._v(" "),a("p",[t._v("在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ；")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220212183524238.png",alt:"image-20220212183524238"}})]),t._v(" "),a("p",[t._v("默认情况下， Redis 将数据库快照保存在名字为==dump.rdb的二进制文件==中。文件名可以在配置文件中进行自定义。")]),t._v(" "),a("h3",{attrs:{id:"工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工作原理"}},[t._v("#")]),t._v(" 工作原理")]),t._v(" "),a("p",[t._v("在进行 RDB 的时候，redis 的主线程是不会做 io 操作的，主线程会 fork 一个子线程来完成该操作；")]),t._v(" "),a("ul",[a("li",[t._v("Redis 调用forks。同时拥有父进程和子进程。")]),t._v(" "),a("li",[t._v("子进程将数据集写入到一个临时 RDB 文件中。")]),t._v(" "),a("li",[t._v("当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。\n==这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益==(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。)")])]),t._v(" "),a("h3",{attrs:{id:"触发机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#触发机制"}},[t._v("#")]),t._v(" 触发机制")]),t._v(" "),a("ol",[a("li",[t._v("save的规则满足的情况下，会自动触发rdb原则")]),t._v(" "),a("li",[t._v("执行flushall命令，也会触发我们的rdb原则")]),t._v(" "),a("li",[t._v("退出redis，也会自动产生rdb文件 (==shutdown==)")])]),t._v(" "),a("h4",{attrs:{id:"save"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#save"}},[t._v("#")]),t._v(" save")]),t._v(" "),a("p",[t._v("使用 "),a("code",[t._v("save")]),t._v(" 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了；")]),t._v(" "),a("blockquote",[a("p",[t._v("由于 "),a("code",[t._v("save")]),t._v(" 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，"),a("code",[t._v("save")]),t._v("命令执行速度会非常慢，阻塞所有客户端的请求。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220212183757671.png",alt:"image-20220212183757671"}})]),t._v(" "),a("h4",{attrs:{id:"flushall命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flushall命令"}},[t._v("#")]),t._v(" flushall命令")]),t._v(" "),a("p",[a("code",[t._v("flushall")]),t._v(" 命令也会触发持久化 ；")]),t._v(" "),a("h4",{attrs:{id:"触发持久化规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#触发持久化规则"}},[t._v("#")]),t._v(" 触发持久化规则")]),t._v(" "),a("p",[t._v("满足配置条件中的触发条件 ；")]),t._v(" "),a("blockquote",[a("p",[t._v("可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220212190044380.png",alt:"image-20220212190044380"}})])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220212190104024.png",alt:"image-20220212190104024"}})]),t._v(" "),a("h4",{attrs:{id:"bgsave"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bgsave"}},[t._v("#")]),t._v(" bgsave")]),t._v(" "),a("p",[a("code",[t._v("bgsave")]),t._v(" 是异步进行，进行持久化的时候，"),a("code",[t._v("redis")]),t._v(" 还可以将继续响应客户端请求 ；")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220212190130772.png",alt:"image-20220212190130772"}})]),t._v(" "),a("h4",{attrs:{id:"bgsave和save对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bgsave和save对比"}},[t._v("#")]),t._v(" "),a("strong",[t._v("bgsave和save对比")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[a("strong",[t._v("命令")])]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[a("strong",[t._v("save")])]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[a("strong",[t._v("bgsave")])])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("IO类型")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("同步")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("异步")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("阻塞？")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是（阻塞发生在fock()，通常非常快）")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("复杂度")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("O(n)")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("O(n)")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("优点")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("不会消耗额外的内存")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("不阻塞客户端命令")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("缺点")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("阻塞客户端命令")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("需要fock子进程，消耗内存")])])])]),t._v(" "),a("h3",{attrs:{id:"优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[t._v("#")]),t._v(" 优缺点")]),t._v(" "),a("p",[a("strong",[t._v("优点：")])]),t._v(" "),a("ol",[a("li",[t._v("适合大规模的数据恢复")]),t._v(" "),a("li",[t._v("对数据的完整性要求不高")])]),t._v(" "),a("p",[a("strong",[t._v("缺点：")])]),t._v(" "),a("ol",[a("li",[t._v("需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。")]),t._v(" "),a("li",[t._v("fork进程的时候，会占用一定的内存空间。")])])])}),[],!1,null,null,null);e.default=v.exports}}]);