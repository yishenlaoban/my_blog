(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{656:function(v,_,t){"use strict";t.r(_);var n=t(3),e=Object(n.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h3",{attrs:{id:"线程的生命周期-线程有几种状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程的生命周期-线程有几种状态"}},[v._v("#")]),v._v(" "),t("strong",[v._v("线程的生命周期？线程有几种状态")])]),v._v(" "),t("p",[v._v("1.线程通常有五种状态，创建，就绪，运行、阻塞和死亡状态。")]),v._v(" "),t("p",[v._v("2.阻塞的情况又分为三种：")]),v._v(" "),t("p",[v._v("(1)、"),t("strong",[v._v("等待阻塞")]),v._v("：运行的线程执行wait方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待")]),v._v(" "),t("p",[v._v("池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify或notifyAll方法才能被唤")]),v._v(" "),t("p",[v._v("醒，wait是object类的方法")]),v._v(" "),t("p",[v._v("(2)、"),t("strong",[v._v("同步阻塞")]),v._v("：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放")]),v._v(" "),t("p",[v._v("入“锁池”中。")]),v._v(" "),t("p",[v._v("(3)、"),t("strong",[v._v("其他阻塞")]),v._v("：运行的线程执行sleep或join方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状")]),v._v(" "),t("p",[v._v("态。当sleep状态超时、join等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。")]),v._v(" "),t("p",[v._v("sleep是Thread类的方法")]),v._v(" "),t("p",[v._v("1**.新建状态（New）**：新创建了一个线程对象。")]),v._v(" "),t("p",[v._v("2."),t("strong",[v._v("就绪状态（Runnable）")]),v._v("：线程对象创建后，其他线程调用了该对象的start方法。该状态的线程位于")]),v._v(" "),t("p",[v._v("可运行线程池中，变得可运行，等待获取CPU的使用权。")]),v._v(" "),t("p",[v._v("3."),t("strong",[v._v("运行状态（Running）")]),v._v("：就绪状态的线程获取了CPU，执行程序代码。")]),v._v(" "),t("p",[v._v("4."),t("strong",[v._v("阻塞状态（Blocked）")]),v._v("：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进")]),v._v(" "),t("p",[v._v("入就绪状态，才有机会转到运行状态。")]),v._v(" "),t("p",[v._v("5."),t("strong",[v._v("死亡状态（Dead）")]),v._v("：线程执行完了或者因异常退出了run方法，该线程结束生命周期。")])])}),[],!1,null,null,null);_.default=e.exports}}]);