(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{578:function(t,e,_){"use strict";_.r(e);var v=_(3),a=Object(v.a)({},(function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"十五、缓存穿透与雪崩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#十五、缓存穿透与雪崩"}},[t._v("#")]),t._v(" 十五、缓存穿透与雪崩")]),t._v(" "),_("h3",{attrs:{id:"缓存穿透-查不到"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透-查不到"}},[t._v("#")]),t._v(" 缓存穿透（查不到）")]),t._v(" "),_("blockquote",[_("p",[t._v("概念")])]),t._v(" "),_("p",[t._v("在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。")]),t._v(" "),_("blockquote",[_("p",[t._v("解决方案")])]),t._v(" "),_("p",[_("strong",[t._v("布隆过滤器")])]),t._v(" "),_("p",[t._v("对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220212235057771.png",alt:"image-20220212235057771"}})]),t._v(" "),_("p",[_("strong",[t._v("缓存空对象")])]),t._v(" "),_("p",[t._v("一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220212235114685.png",alt:"image-20220212235114685"}})]),t._v(" "),_("p",[t._v("这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是==设置较短过期时间==")]),t._v(" "),_("p",[t._v("即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。")]),t._v(" "),_("h3",{attrs:{id:"缓存击穿-量太大-缓存过期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿-量太大-缓存过期"}},[t._v("#")]),t._v(" 缓存击穿（量太大，缓存过期）")]),t._v(" "),_("blockquote",[_("p",[t._v("概念")])]),t._v(" "),_("p",[t._v("相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。")]),t._v(" "),_("p",[t._v("比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。")]),t._v(" "),_("blockquote",[_("p",[t._v("解决方案")])]),t._v(" "),_("p",[_("strong",[t._v("设置热点数据永不过期")])]),t._v(" "),_("p",[t._v("这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。")]),t._v(" "),_("p",[_("strong",[t._v("加互斥锁(分布式锁)")])]),t._v(" "),_("p",[t._v("在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。")]),t._v(" "),_("h3",{attrs:{id:"缓存雪崩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[t._v("#")]),t._v(" 缓存雪崩")]),t._v(" "),_("blockquote",[_("p",[t._v("概念")])]),t._v(" "),_("p",[t._v("大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220212235306413.png",alt:"image-20220212235306413"}})]),t._v(" "),_("blockquote",[_("p",[t._v("解决方案")])]),t._v(" "),_("ul",[_("li",[_("p",[t._v("redis高可用")]),t._v(" "),_("p",[t._v("这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群")])]),t._v(" "),_("li",[_("p",[t._v("限流降级")]),t._v(" "),_("p",[t._v("这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。")])]),t._v(" "),_("li",[_("p",[t._v("数据预热")]),t._v(" "),_("p",[t._v("数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);