<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试-计算机网络 | 升升狠のBlog</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/my_blog/favicon.ico">
    <meta name="description" content="看清生活的本质，依旧热爱生活 。">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <link rel="preload" href="/my_blog/assets/css/0.styles.ad4f4074.css" as="style"><link rel="preload" href="/my_blog/assets/js/app.c3dec6d6.js" as="script"><link rel="preload" href="/my_blog/assets/js/3.3346af26.js" as="script"><link rel="preload" href="/my_blog/assets/js/1.d09d735b.js" as="script"><link rel="preload" href="/my_blog/assets/js/120.cf9e7347.js" as="script"><link rel="prefetch" href="/my_blog/assets/js/10.973da536.js"><link rel="prefetch" href="/my_blog/assets/js/100.c5a31228.js"><link rel="prefetch" href="/my_blog/assets/js/101.88a569cf.js"><link rel="prefetch" href="/my_blog/assets/js/102.3a9afbf8.js"><link rel="prefetch" href="/my_blog/assets/js/103.022116bb.js"><link rel="prefetch" href="/my_blog/assets/js/104.3945f572.js"><link rel="prefetch" href="/my_blog/assets/js/105.551d1a9b.js"><link rel="prefetch" href="/my_blog/assets/js/106.780bdaa1.js"><link rel="prefetch" href="/my_blog/assets/js/107.918bcea8.js"><link rel="prefetch" href="/my_blog/assets/js/108.9fd1410e.js"><link rel="prefetch" href="/my_blog/assets/js/109.d8b157d6.js"><link rel="prefetch" href="/my_blog/assets/js/11.4757b58b.js"><link rel="prefetch" href="/my_blog/assets/js/110.5b6a651b.js"><link rel="prefetch" href="/my_blog/assets/js/111.53715a99.js"><link rel="prefetch" href="/my_blog/assets/js/112.4830c19a.js"><link rel="prefetch" href="/my_blog/assets/js/113.ebf08083.js"><link rel="prefetch" href="/my_blog/assets/js/114.8ddbae78.js"><link rel="prefetch" href="/my_blog/assets/js/115.5d8f542f.js"><link rel="prefetch" href="/my_blog/assets/js/116.ecd5cce6.js"><link rel="prefetch" href="/my_blog/assets/js/117.739a2920.js"><link rel="prefetch" href="/my_blog/assets/js/118.7aba9c7e.js"><link rel="prefetch" href="/my_blog/assets/js/119.d98b418b.js"><link rel="prefetch" href="/my_blog/assets/js/12.c5d82084.js"><link rel="prefetch" href="/my_blog/assets/js/121.6a221c64.js"><link rel="prefetch" href="/my_blog/assets/js/122.277457e0.js"><link rel="prefetch" href="/my_blog/assets/js/123.0b0d0427.js"><link rel="prefetch" href="/my_blog/assets/js/124.0901d5ac.js"><link rel="prefetch" href="/my_blog/assets/js/13.20e234f3.js"><link rel="prefetch" href="/my_blog/assets/js/14.54806bda.js"><link rel="prefetch" href="/my_blog/assets/js/15.fbbcbd80.js"><link rel="prefetch" href="/my_blog/assets/js/16.3114a198.js"><link rel="prefetch" href="/my_blog/assets/js/17.ec0bf579.js"><link rel="prefetch" href="/my_blog/assets/js/18.f39201ed.js"><link rel="prefetch" href="/my_blog/assets/js/19.8c8da72b.js"><link rel="prefetch" href="/my_blog/assets/js/20.d6546a02.js"><link rel="prefetch" href="/my_blog/assets/js/21.38a056dc.js"><link rel="prefetch" href="/my_blog/assets/js/22.8ad7a94e.js"><link rel="prefetch" href="/my_blog/assets/js/23.6472c470.js"><link rel="prefetch" href="/my_blog/assets/js/24.5d6c1c78.js"><link rel="prefetch" href="/my_blog/assets/js/25.dafb6777.js"><link rel="prefetch" href="/my_blog/assets/js/26.0e396082.js"><link rel="prefetch" href="/my_blog/assets/js/27.f456ca91.js"><link rel="prefetch" href="/my_blog/assets/js/28.36bdb89b.js"><link rel="prefetch" href="/my_blog/assets/js/29.5296302d.js"><link rel="prefetch" href="/my_blog/assets/js/30.ab995e8d.js"><link rel="prefetch" href="/my_blog/assets/js/31.1f44d912.js"><link rel="prefetch" href="/my_blog/assets/js/32.804b9296.js"><link rel="prefetch" href="/my_blog/assets/js/33.c0916ab8.js"><link rel="prefetch" href="/my_blog/assets/js/34.d983ccb4.js"><link rel="prefetch" href="/my_blog/assets/js/35.7083c08b.js"><link rel="prefetch" href="/my_blog/assets/js/36.e00bd271.js"><link rel="prefetch" href="/my_blog/assets/js/37.71e49109.js"><link rel="prefetch" href="/my_blog/assets/js/38.07da48d1.js"><link rel="prefetch" href="/my_blog/assets/js/39.536abcae.js"><link rel="prefetch" href="/my_blog/assets/js/4.49a80f60.js"><link rel="prefetch" href="/my_blog/assets/js/40.d36ba39e.js"><link rel="prefetch" href="/my_blog/assets/js/41.77a7e50d.js"><link rel="prefetch" href="/my_blog/assets/js/42.f1e157ed.js"><link rel="prefetch" href="/my_blog/assets/js/43.44c063c6.js"><link rel="prefetch" href="/my_blog/assets/js/44.4811c42e.js"><link rel="prefetch" href="/my_blog/assets/js/45.39e536a0.js"><link rel="prefetch" href="/my_blog/assets/js/46.dbc45219.js"><link rel="prefetch" href="/my_blog/assets/js/47.04f3bfb2.js"><link rel="prefetch" href="/my_blog/assets/js/48.e68cbf44.js"><link rel="prefetch" href="/my_blog/assets/js/49.4a994ed4.js"><link rel="prefetch" href="/my_blog/assets/js/5.238aee53.js"><link rel="prefetch" href="/my_blog/assets/js/50.4d91b116.js"><link rel="prefetch" href="/my_blog/assets/js/51.2d26bf78.js"><link rel="prefetch" href="/my_blog/assets/js/52.cf064be7.js"><link rel="prefetch" href="/my_blog/assets/js/53.17d3517b.js"><link rel="prefetch" href="/my_blog/assets/js/54.78f240b4.js"><link rel="prefetch" href="/my_blog/assets/js/55.2f071008.js"><link rel="prefetch" href="/my_blog/assets/js/56.a300ee7a.js"><link rel="prefetch" href="/my_blog/assets/js/57.4815b76c.js"><link rel="prefetch" href="/my_blog/assets/js/58.1286fb05.js"><link rel="prefetch" href="/my_blog/assets/js/59.abb35058.js"><link rel="prefetch" href="/my_blog/assets/js/6.5254465b.js"><link rel="prefetch" href="/my_blog/assets/js/60.83b3ccd2.js"><link rel="prefetch" href="/my_blog/assets/js/61.b5501b81.js"><link rel="prefetch" href="/my_blog/assets/js/62.b43c7153.js"><link rel="prefetch" href="/my_blog/assets/js/63.63259558.js"><link rel="prefetch" href="/my_blog/assets/js/64.e2351a3b.js"><link rel="prefetch" href="/my_blog/assets/js/65.32a0e4a2.js"><link rel="prefetch" href="/my_blog/assets/js/66.1f7dd088.js"><link rel="prefetch" href="/my_blog/assets/js/67.71679a3f.js"><link rel="prefetch" href="/my_blog/assets/js/68.9c0d8cbd.js"><link rel="prefetch" href="/my_blog/assets/js/69.ba2cfe5b.js"><link rel="prefetch" href="/my_blog/assets/js/7.8f01f368.js"><link rel="prefetch" href="/my_blog/assets/js/70.73bac804.js"><link rel="prefetch" href="/my_blog/assets/js/71.8735d774.js"><link rel="prefetch" href="/my_blog/assets/js/72.7d0f80cf.js"><link rel="prefetch" href="/my_blog/assets/js/73.6f46bcca.js"><link rel="prefetch" href="/my_blog/assets/js/74.4e2f68b8.js"><link rel="prefetch" href="/my_blog/assets/js/75.2097f32c.js"><link rel="prefetch" href="/my_blog/assets/js/76.44263639.js"><link rel="prefetch" href="/my_blog/assets/js/77.f79bb8d4.js"><link rel="prefetch" href="/my_blog/assets/js/78.619e5d8b.js"><link rel="prefetch" href="/my_blog/assets/js/79.c774c6bc.js"><link rel="prefetch" href="/my_blog/assets/js/8.428b0c05.js"><link rel="prefetch" href="/my_blog/assets/js/80.04133b5e.js"><link rel="prefetch" href="/my_blog/assets/js/81.6d5e814b.js"><link rel="prefetch" href="/my_blog/assets/js/82.faffa019.js"><link rel="prefetch" href="/my_blog/assets/js/83.1d436e17.js"><link rel="prefetch" href="/my_blog/assets/js/84.43fad778.js"><link rel="prefetch" href="/my_blog/assets/js/85.8edc4cff.js"><link rel="prefetch" href="/my_blog/assets/js/86.0b0832f3.js"><link rel="prefetch" href="/my_blog/assets/js/87.ad19f313.js"><link rel="prefetch" href="/my_blog/assets/js/88.249b7285.js"><link rel="prefetch" href="/my_blog/assets/js/89.b13f8876.js"><link rel="prefetch" href="/my_blog/assets/js/9.9950b82a.js"><link rel="prefetch" href="/my_blog/assets/js/90.757dd84d.js"><link rel="prefetch" href="/my_blog/assets/js/91.019d356a.js"><link rel="prefetch" href="/my_blog/assets/js/92.2fe899a9.js"><link rel="prefetch" href="/my_blog/assets/js/93.7ea8d772.js"><link rel="prefetch" href="/my_blog/assets/js/94.b6d159f9.js"><link rel="prefetch" href="/my_blog/assets/js/95.e63d7373.js"><link rel="prefetch" href="/my_blog/assets/js/96.1aeb8ed0.js"><link rel="prefetch" href="/my_blog/assets/js/97.0c7a4a4c.js"><link rel="prefetch" href="/my_blog/assets/js/98.900d6e40.js"><link rel="prefetch" href="/my_blog/assets/js/99.8418c623.js">
    <link rel="stylesheet" href="/my_blog/assets/css/0.styles.ad4f4074.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-2d5f533b><div data-v-2d5f533b><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-2d5f533b data-v-2d5f533b><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-2d5f533b data-v-2d5f533b><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>升升狠のBlog</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>yishenlaoban</span>
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-2d5f533b><header class="navbar" data-v-2d5f533b><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/my_blog/" class="home-link router-link-active"><img src="/my_blog/logo.png" alt="升升狠のBlog" class="logo"> <span class="site-name">升升狠のBlog</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/my_blog/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      目录索引
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my_blog/categories/数据库/" class="nav-link"><i class="iconfont undefined"></i>
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/my_blog/categories/框架/" class="nav-link"><i class="iconfont undefined"></i>
  框架
</a></li><li class="dropdown-item"><!----> <a href="/my_blog/categories/java/" class="nav-link"><i class="iconfont undefined"></i>
  java
</a></li><li class="dropdown-item"><!----> <a href="/my_blog/categories/Linux/" class="nav-link"><i class="iconfont undefined"></i>
  Linux
</a></li><li class="dropdown-item"><!----> <a href="/my_blog/categories/多线程/" class="nav-link"><i class="iconfont undefined"></i>
  多线程
</a></li><li class="dropdown-item"><!----> <a href="/my_blog/categories/工具/" class="nav-link"><i class="iconfont undefined"></i>
  工具
</a></li><li class="dropdown-item"><!----> <a href="/my_blog/categories/算法/" class="nav-link"><i class="iconfont undefined"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/my_blog/categories/面试/" class="nav-link"><i class="iconfont undefined"></i>
  面试
</a></li></ul></div></div><div class="nav-item"><a href="/my_blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签索引
</a></div><div class="nav-item"><a href="/my_blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yishenlaoban" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/m0_51302110?spm=1000.2115.3001.5343" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-csdn"></i>
  CSDN
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-2d5f533b></div> <aside class="sidebar" data-v-2d5f533b><div class="personal-info-wrapper" data-v-ca798c94 data-v-2d5f533b><img src="/my_blog/avatar.jpg" alt="author-avatar" class="personal-img" data-v-ca798c94> <h3 class="name" data-v-ca798c94>
    yishenlaoban
  </h3> <div class="num" data-v-ca798c94><div data-v-ca798c94><h3 data-v-ca798c94>113</h3> <h6 data-v-ca798c94>Article</h6></div> <div data-v-ca798c94><h3 data-v-ca798c94>41</h3> <h6 data-v-ca798c94>Tag</h6></div></div> <hr data-v-ca798c94></div> <nav class="nav-links"><div class="nav-item"><a href="/my_blog/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      目录索引
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my_blog/categories/数据库/" class="nav-link"><i class="iconfont undefined"></i>
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/my_blog/categories/框架/" class="nav-link"><i class="iconfont undefined"></i>
  框架
</a></li><li class="dropdown-item"><!----> <a href="/my_blog/categories/java/" class="nav-link"><i class="iconfont undefined"></i>
  java
</a></li><li class="dropdown-item"><!----> <a href="/my_blog/categories/Linux/" class="nav-link"><i class="iconfont undefined"></i>
  Linux
</a></li><li class="dropdown-item"><!----> <a href="/my_blog/categories/多线程/" class="nav-link"><i class="iconfont undefined"></i>
  多线程
</a></li><li class="dropdown-item"><!----> <a href="/my_blog/categories/工具/" class="nav-link"><i class="iconfont undefined"></i>
  工具
</a></li><li class="dropdown-item"><!----> <a href="/my_blog/categories/算法/" class="nav-link"><i class="iconfont undefined"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/my_blog/categories/面试/" class="nav-link"><i class="iconfont undefined"></i>
  面试
</a></li></ul></div></div><div class="nav-item"><a href="/my_blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签索引
</a></div><div class="nav-item"><a href="/my_blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yishenlaoban" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/m0_51302110?spm=1000.2115.3001.5343" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-csdn"></i>
  CSDN
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>面试</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/my_blog/blogs/work/interview/001.面试-java.html" class="sidebar-link">面试-Java</a></li><li><a href="/my_blog/blogs/work/interview/003.面试-计算机网络.html" class="active sidebar-link">面试-计算机网络</a></li><li><a href="/my_blog/blogs/work/interview/005.面试-操作系统.html" class="sidebar-link">面试-操作系统</a></li><li><a href="/my_blog/blogs/work/interview/007.面试-Spring.html" class="sidebar-link">面试-Spring</a></li><li><a href="/my_blog/blogs/work/interview/008.面试-面经.html" class="sidebar-link">面试-面经</a></li><li><a href="/my_blog/blogs/work/interview/009.面试-多线程.html" class="sidebar-link">面试-多线程</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-2d5f533b><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>面试-计算机网络</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>yishenlaoban</span>
            
          <!---->
          2022
        </a></span></div></div> <div data-v-2d5f533b><main class="page"><div class="page-title" style="display:none;"><h1 class="title">面试-计算机网络</h1> <div data-v-3b7f5bdf><i class="iconfont reco-account" data-v-3b7f5bdf><span data-v-3b7f5bdf>yishenlaoban</span></i> <i class="iconfont reco-date" data-v-3b7f5bdf><span data-v-3b7f5bdf>2022-03-05</span></i> <i class="iconfont reco-eye" data-v-3b7f5bdf><span id="/my_blog/blogs/work/interview/003.%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-3b7f5bdf><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="iconfont reco-tag tags" data-v-3b7f5bdf><span class="tag-item" data-v-3b7f5bdf>计算机网络</span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><p>人生中，成功都是暂时的，失败才是主旋律，如何面对失败</p> <h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="header-anchor">#</a> 计算机网络的体系结构</h2> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220305210207437.png" alt="image-20220305210207437"></p> <h2 id="链路层"><a href="#链路层" class="header-anchor">#</a> 链路层</h2> <blockquote><p>封装成帧：数据链路层给上层交付的协议数据单元<strong>添加帧头和帧尾</strong>使之成为帧</p> <p>​             帧头和帧尾中包含有重要的控制信息；（MAC地址，校验码）</p> <p>​             帧头和帧尾的作用之一就是<strong>帧定界</strong></p> <p>透明传输：指数据链路层<strong>对上层交付的传输数据没有任何限制</strong>，就好像数据链路层不存在一样。</p> <p>​        就是给数据中出现的特殊码加转义，如：<strong>帧定界</strong>，<strong>转义码本身</strong></p> <ul><li><p>面向字节的物理链路使用<strong>字节填充</strong>（或称字符填充)的方法实现透明传输。</p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220305202225531.png" alt="image-20220305202225531"></p></li> <li><p>面向比特的物理链路使用<strong>比特填充</strong>的方法实现透明传输。</p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220305202454954.png" alt="image-20220305202454954"></p></li></ul> <p>差错检验：在传输过程中可能会产生比特差错：1 可能会变成 0， 而 0 也可能变成 1。在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate)，误码率与信噪比有很大的关系，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施，在数据链路层传送的帧中，广泛使用了<strong>循环冗余检验 CRC</strong> 的检错技术</p></blockquote> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220305204736571.png" alt="image-20220305204736571"></p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220305204811483.png" alt="image-20220305204811483"></p> <h2 id="传输层"><a href="#传输层" class="header-anchor">#</a> 传输层</h2> <h3 id="_1-tcp三次握手"><a href="#_1-tcp三次握手" class="header-anchor">#</a> 1.TCP三次握手</h3> <p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p> <p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。
进行三次握手：</p> <ul><li><p>第一次握手：(<code>客户端给服务器发送TCP连接请求</code>)客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SENT 状态。</p> <p>首部的同步位SYN=1，初始序号seq=x，<code>TCP的标准规定，SYN=1的报文段不能携带数据，但要消耗掉一个序号</code>。</p></li> <li><p>第二次握手：(<code>服务器给客户端发送针对TCP连接请求的确认</code>)服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于<code>SYN_RCVD</code>的状态。</p> <p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p></li> <li><p>第三次握手：(<code>客户端给服务器发送针对TCP连接请求的确认的确认</code>)客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于<code>ESTABLISHED</code>状态。服务器收到 ACK 报文之后，也处于<code>ESTABLISHED</code>状态，此时，双方已建立起了连接。</p> <p>确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p> <p><code>TCP的标准规定，普通的确认报文，如果不携带数据，则不消耗序号</code></p></li></ul> <p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p> <p>在socket编程中，客户端执行connect()时，将触发三次握手。</p> <p><strong>下图中服务器发送给客户端的确认报文中，服务端的初始序号seq=y，可由服务端随机指定，与其他报文段中的值无关</strong></p> <p><img src="https://gitee.com/hnistzdk/picture/raw/master/images/202203082124618.png" alt="image-20220308212459522"></p> <h4 id="_1-1为什么需要三次握手-两次不行吗"><a href="#_1-1为什么需要三次握手-两次不行吗" class="header-anchor">#</a> 1.1为什么需要三次握手，两次不行吗？</h4> <p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p> <ul><li><p>第一次握手：客户端发送网络包，服务端收到了。
这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p></li> <li><p>第二次握手：服务端发包，客户端收到了。
这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p></li> <li><p>第三次握手：客户端发包，服务端收到了。
这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p> <p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p></li></ul> <p>试想如果是用两次握手，则会出现下面这种情况：</p> <blockquote><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在<code>某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端</code>，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p></blockquote> <p><code>所以不采用两次握手是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致服务器长时间等待，浪费资源</code></p> <h4 id="_1-2-什么是半连接队列"><a href="#_1-2-什么是半连接队列" class="header-anchor">#</a> 1.2 什么是半连接队列？</h4> <p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个<code>队列</code>里，我们把这种队列称之为<code>半连接队列</code>。</p> <p>当然还有一个<code>全连接队列</code>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p> <p>这里在补充一点关于<code>SYN-ACK 重传次数</code>的问题：
服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。
注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p> <h4 id="_1-3-isn-initial-sequence-number-是固定的吗"><a href="#_1-3-isn-initial-sequence-number-是固定的吗" class="header-anchor">#</a> 1.3 ISN(Initial Sequence Number)是固定的吗？</h4> <p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</p> <p><strong>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</strong></p> <h4 id="_1-4-三次握手过程中可以携带数据吗"><a href="#_1-4-三次握手过程中可以携带数据吗" class="header-anchor">#</a> 1.4 三次握手过程中可以携带数据吗？</h4> <p>其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据</p> <p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p> <p>也就是说，<strong>第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</strong></p> <h4 id="_1-5-syn攻击是什么"><a href="#_1-5-syn攻击是什么" class="header-anchor">#</a> 1.5 SYN攻击是什么？</h4> <blockquote><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。</p></blockquote> <p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstat 命令来检测 SYN 攻击。</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token function">netstat</span> -n -p TCP <span class="token operator">|</span> <span class="token function">grep</span> SYN_RECV
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>常见的防御 SYN 攻击的方法有如下几种：</p> <ul><li>缩短超时（SYN Timeout）时间</li> <li>增加最大半连接数</li> <li>过滤网关防护</li> <li>SYN cookies技术</li></ul> <h3 id="_2-tcp四次挥手"><a href="#_2-tcp四次挥手" class="header-anchor">#</a> 2.TCP四次挥手</h3> <p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p> <p>TCP 连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务端均可主动发起挥手动作。</p> <p>刚开始双方都处于<code>ESTABLISHED</code>状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p> <ul><li><p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。
即发出<code>连接释放报文段</code>（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入<code>FIN_WAIT1</code>（终止等待1）状态，等待服务端的确认。</p> <p><code>序号seq=u中的u等于TCP客户进程之前传送过的数据的最后一个字节+1</code></p> <p><code>TCP规定，终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</code></p> <p><code>ack字段的值v等于客户进程之前已收到的数据的最后一个字节的序号+1</code>(等于服务器进程传送过的数据的最后一个字节)</p></li> <li><p>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于<code>CLOSE_WAIT</code>状态。
即服务端收到连接释放报文段后即发出<code>确认报文段</code>（ACK=1，确认号ack=u+1，序号seq=v），服务端进入<code>CLOSE_WAIT</code>（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入<code>FIN_WAIT2</code>（终止等待2）状态，等待服务端发出的连接释放报文段。</p> <p><code>seq=v中的v等于TCP服务器进程之前已传送过的数据的最后一个字节的序号+1</code></p> <p><code>ack=u+1中的u等于TCP服务器进程之前已收到的数据的最后一个字节的序号+1</code></p></li> <li><p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态。
即服务端没有要向客户端发出的数据，服务端发出<code>连接释放报文段</code>（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入<code>LAST_ACK</code>（最后确认）状态，等待客户端的确认。</p></li> <li><p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于<code>TIME_WAIT</code>状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 <code>CLOSED</code> 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于<code>CLOSED</code> 状态。
即客户端收到服务端的连接释放报文段后，对此发出<code>确认报文段</code>（ACK=1，seq=u+1，ack=w+1），客户端进入<code>TIME_WAIT</code>（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入<code>CLOSED</code>状态。</p></li></ul> <p>收到一个FIN只意味着在这一方向上没有数据流动。<strong>客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</strong></p> <p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p> <p><img src="https://gitee.com/hnistzdk/picture/raw/master/images/202203082117725.png" alt="image-20220308211717617"></p> <h4 id="_2-1-挥手为什么需要四次"><a href="#_2-1-挥手为什么需要四次" class="header-anchor">#</a> 2.1 挥手为什么需要四次？</h4> <p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中<strong>ACK报文是用来应答的，SYN报文是用来同步的</strong>。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p> <h4 id="_2-2-2msl等待状态"><a href="#_2-2-2msl等待状态" class="header-anchor">#</a> 2.2 2MSL等待状态</h4> <p>如果客户端不等待，而是直接关闭，会导致以下情况</p> <p><img src="https://gitee.com/hnistzdk/picture/raw/master/images/202203082120301.png" alt="image-20220308212041201"></p> <blockquote><p><strong>MSL</strong>是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p></blockquote> <blockquote><p>TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p> <p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p> <p>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</p></blockquote> <h4 id="_2-3-四次挥手释放连接时-等待2msl的意义"><a href="#_2-3-四次挥手释放连接时-等待2msl的意义" class="header-anchor">#</a> 2.3 四次挥手释放连接时，等待2MSL的意义？</h4> <blockquote><p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p></blockquote> <h4 id="两个理由"><a href="#两个理由" class="header-anchor">#</a> 两个理由：</h4> <ol><li><p><strong>保证客户端发送的最后一个ACK报文段能够到达服务端</strong>。</p> <blockquote><p>这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</p></blockquote></li> <li><p><strong>防止“已失效的连接请求报文段”出现在本连接中</strong>。</p> <blockquote><p>客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p></blockquote></li></ol> <h4 id="_2-4-服务器端的保活计时器"><a href="#_2-4-服务器端的保活计时器" class="header-anchor">#</a> 2.4 服务器端的保活计时器</h4> <p><img src="https://gitee.com/hnistzdk/picture/raw/master/images/202203082123458.png" alt="image-20220308212339364"></p> <h4 id="_2-5-为什么time-wait状态需要经过2msl才能返回到close状态"><a href="#_2-5-为什么time-wait状态需要经过2msl才能返回到close状态" class="header-anchor">#</a> 2.5 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</h4> <blockquote><p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以<strong>TIME_WAIT状态就是用来重发可能丢失的ACK报文</strong>。</p></blockquote> <h4 id="_2-6-tcp状态变迁图"><a href="#_2-6-tcp状态变迁图" class="header-anchor">#</a> 2.6 TCP状态变迁图</h4> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203052006278.png" alt="TCP状态变迁图.jpg"></p> <h3 id="_3-tcp和udp是什么"><a href="#_3-tcp和udp是什么" class="header-anchor">#</a> 3.TCP和UDP是什么</h3> <blockquote><p>TCP：
传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793 定义。</p></blockquote> <blockquote><p>UDP：
Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。RFC 768 描述了 UDP。</p></blockquote> <h3 id="_4-tcp和udp有什么区别"><a href="#_4-tcp和udp有什么区别" class="header-anchor">#</a> 4.TCP和UDP有什么区别</h3> <p><img src="https://gitee.com/hnistzdk/picture/raw/master/images/202203082126567.png" alt="image-20220308212601476"></p> <ol><li><p><code>TCP面向连接，通过三次握手建立连接，四次挥手接除连接</code>;<code>UDP是无连接的，即发送数据之前不需要建立连接</code>，这种方式为UDP带来了高效的传输效率，但也导致无法确保数据的发送成功。</p></li> <li><p><code>TCP是可靠的通信方式</code>。通过TCP连接传送的数据，TCP通过超时重传、 数据校验等方式来确保数据无差错，不丢失，不重复，且按序到达；而UDP由于无需连接的原因，将会以最大速度进行传输，<code>但不保证可靠交付，也就是会出现丢失、重复等等问题</code>。</p></li> <li><p><code>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流</code>，由于连接的问题，当网络出现波动时，连接可能出现响应问题；<code>UDP对应用进程交下来的报文既不合并也不拆分，即UDP是面向应用报文的</code>,UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。</p> <p><img src="https://gitee.com/hnistzdk/picture/raw/master/images/202203082138273.png" alt="image-20220308213813176"></p></li> <li><p><code>每一条TCP连接只能是点到点的</code>；而UDP不建立连接，所以可以支持<code>一对一，一对多，多对一和多对多</code>的交互通信，也就是可以同时接受多个人的包。</p></li> <li><p>TCP需要建立连接，首部开销20字节相比8个字节的UDP显得比较大。</p></li> <li><p>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。</p></li></ol> <h3 id="_5-tcp维护可靠的通信方式"><a href="#_5-tcp维护可靠的通信方式" class="header-anchor">#</a> 5.TCP维护可靠的通信方式</h3> <ol><li>数据分片：在发送端对用户数据进行分片，在接收端进行重组，由TCP确定分片的大小并控制分片和重组；</li> <li>到达确认：接收端接收到分片数据时，根据分片数据序号向发送端发送一个确认包；</li> <li>超时重发：发送方在发送分片后计时，若超时却没有收到相应的确认包，将会重发对应的分片；</li> <li>滑动窗口：TCP连接双方的接收缓冲空间大小都固定，接收端只能接受缓冲区能接纳的数据。</li> <li>失序处理：TCP的接收端需要重新排序接收到的数据。</li> <li>重复处理：如果传输的TCP分片出现重复，TCP的接收端需要丢弃重复的数据。</li> <li>数据校验：TCP通过保持它首部和数据的检验和来检测数据在传输过程中的任何变化。</li></ol> <h3 id="_6-tcp-ip的流量控制"><a href="#_6-tcp-ip的流量控制" class="header-anchor">#</a> 6.TCP/IP的流量控制</h3> <ol><li><p>需要流量控制的原因</p> <blockquote><p>数据发送的过快接受放来不及接受会造成数据丢书</p></blockquote></li> <li><p>如何控制</p> <blockquote><p>让发送方的发生速率不要太快，接收方来得及接受</p></blockquote></li> <li><p>具体：滑动窗口机制，窗口指发送未收到确认的数据段都在这里</p> <ul><li>由接收方控制流量，收到的数据会发送确认，确认之后发送方的窗口会向前滑动发送接下来的字节</li> <li>当接收方没有内存会告诉发送方能接受的字节为0 ，但是这个消息可能会丢失，丢失之后发送方和接收方都会一直等待对方发送数据，会形成死锁</li> <li>首先如果接收方收到0字节通知会启动一个持续计时器，计时器超时的话会发送一个0窗口探测报文，接收方收到就会返回自己现在能接受的数据大小，死锁解除，如果还是0就再开启一个计时器</li> <li>如果零窗口探测报文丢失的话，也有一个计时器，这个计时器超时探测报文也会重传</li></ul></li></ol> <h4 id="_6-1-滑动窗口机制"><a href="#_6-1-滑动窗口机制" class="header-anchor">#</a> 6.1 滑动窗口机制</h4> <p><strong>滑动窗口通俗来讲就是一种流量控制技术</strong></p> <p>它<strong>本质上是描述接收方的TCP数据报缓冲区大小的数据</strong>，发送方根据这个数据来计算自己最多能发送多长的数据，如果发送方收到接收方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接收方发送窗口大小不为0的数据报的到来</p> <p>所谓滑动窗口协议，自己理解有两点：1. “窗口”对应的是一段可以被发送者发送的字节序列，其连续的范围称之为“窗口”；2. “滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”。在引入一个例子来说这个协议之前，我觉得很有必要先了解以下前提：</p> <ol><li>TCP协议的两端分别为发送者A和接收者B，由于是全双工协议，因此A和B应该分别维护着一个独立的发送缓冲区和接收缓冲区，由于对等性（A发B收和B发A收），我们以A发送B接收的情况作为例子；</li> <li>发送窗口是发送缓存中的一部分，是可以被TCP协议发送的那部分，其实应用层需要发送的所有数据都被放进了发送者的发送缓冲区；</li> <li>发送窗口中相关的有四个概念：已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之中）、允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不允许发送的数据；</li> <li>每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送；</li></ol> <p>TCP建立连接的初始，B会告诉A自己的接收窗口大小，比如为‘20’：
字节31-50为发送窗口</p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203052030185.png" alt="img"></p> <p>A发送11个字节后，发送窗口位置不变，B接收到了乱序的数据分组：</p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203052030145.png" alt="img"></p> <p>只有当A成功发送了数据，即发送的数据得到了B的确认之后，才会移动滑动窗口离开已发送的数据；同时B则确认连续的数据分组，对于乱序的分组则先接收下来，避免网络重复传递：</p> <p><img src="https://gitee.com/hnistzdk/picture/raw/master/images/202203052030051.png" alt="img"></p> <p>如果出现丢包现象：（如图中的7、8、9丢失）</p> <p><img src="https://gitee.com/hnistzdk/picture/raw/master/images/202203052031396.png" alt="img"></p> <p><code>B给A发确认号为7，确认数据包中有“选择性确认段”，此时A只发送丢失的7-9，而不会再发10-12。</code></p> <h4 id="_6-2-传递效率"><a href="#_6-2-传递效率" class="header-anchor">#</a> 6.2 传递效率</h4> <blockquote><p>一个显而易见的问题是：单个发送字节单个确认，和窗口有一个空余即通知发送方发送一个字节，无疑增加了网络中的许多不必要的报文（请想想为了一个字节数据而添加的40字节头部吧！），所以我们的原则是尽可能一次多发送几个字节，或者窗口空余较多的时候通知发送方一次发送多个字节。对于前者我们广泛使用Nagle算法，即：</p> <ol><li>若发送应用进程要把发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面的字节先缓存起来；</li> <li>当发送方收到第一个字节的确认后（也得到了网络情况和对方的接收窗口大小），再把缓冲区的剩余字节组成合适大小的报文发送出去；</li> <li>当到达的数据已达到发送窗口大小的一半或以达到报文段的最大长度时，就立即发送一个报文段；对于后者我们往往的做法是让接收方等待一段时间，或者接收方获得足够的空间容纳一个报文段或者等到接受缓存有一半空闲的时候，再通知发送方发送数据。</li></ol></blockquote> <h3 id="_7-拥塞控制"><a href="#_7-拥塞控制" class="header-anchor">#</a> 7.拥塞控制</h3> <h4 id="_7-1-什么是拥塞-什么是拥塞控制"><a href="#_7-1-什么是拥塞-什么是拥塞控制" class="header-anchor">#</a> 7.1 什么是拥塞？什么是拥塞控制？</h4> <blockquote><p>在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就称为<strong>拥塞</strong>。简单的说<strong>拥塞产生的原因有两点：</strong>（1）接收方容量不够（2）网络内部有瓶颈</p></blockquote> <blockquote><p><strong>拥塞控制</strong>就是防止过多的数据注入到网络中，这样可以使网络中的<code>路由器或链路</code>不致过载。</p></blockquote> <h4 id="_7-2-检测网络拥塞的方法"><a href="#_7-2-检测网络拥塞的方法" class="header-anchor">#</a> 7.2 检测网络拥塞的方法？</h4> <blockquote><ol><li><p>发送数据后规定时间没有收到回应可以判定堵塞</p></li> <li><p>发送数据后收到同一条报文的四次确认，可认为丢失-------------这种情况就是根据TCP传输数据的特点：发送12345个数据段，接受端收到1的时候会返回2的确认报文也就是说我收到了2之前的下一次我就想要2了--------收到2之后返回3的确认报文------但是现在3迟迟未到-------4到了储存下来还是返回3的确认---5到了还是如此----然后3才到又发现缓存里面有45就返回6的确认报文表示之前的我都收到了，</p> <p>若发送方接收到对同一条报文的三次冗余确认（也就是四次确认），就认为这条报文的下一条已经丢失，于是不管计时器是否超时，都直接重传这条报文的下一条。快速重传的条件发生，发送方将认为出现了拥塞导致丢包。</p> <p>所以TCP判断拥塞就是判断有没有丢包</p></li></ol></blockquote> <h4 id="_7-3-网络拥塞的表现"><a href="#_7-3-网络拥塞的表现" class="header-anchor">#</a> 7.3 网络拥塞的表现？</h4> <blockquote><p>主机ab通话，由主机a发送数据给主机b的时候不是直达，而是通过网络中的路由器等等，-----</p> <p>路由器先储存这些数据，然后再从中取出，根据数据中的地址转发给下一个离主机b近的路由器或者直接到达主机b-----</p> <p>有一个问题就是路由器的内存是有限的，如果同一时间到达的数据太多路由器接受不了就只能丢弃一部分，或者路由器数据本来就多后来的数据就要等很长时间才能转发</p> <p><strong>所以网络中数据太多，路由器处理不过来或者太慢就是网络拥塞</strong></p></blockquote> <h4 id="_7-4-tcp-ip协议的拥塞控制"><a href="#_7-4-tcp-ip协议的拥塞控制" class="header-anchor">#</a> 7.4 TCP/IP协议的拥塞控制？</h4> <p><code>TCP</code>进行拥塞控制的四种算法：慢开始、拥塞避免、快速重传、快速恢复。</p> <ul><li><strong>MSS</strong>：最大报文段长度，<code>TCP</code>双方发送的报文段中，包含的数据部分的最大字节数；</li> <li><strong>cwnd</strong>：拥塞窗口，<code>TCP</code>发送但还没有得到确认的报文的序号都在这个区间；</li> <li><strong>RTT</strong>：往返时间，发送方发送一个报文，到接收这个报文的确认报文所经历的时间；</li> <li><strong>ssthresh</strong>：慢启动阈值，慢启动阶段，若<code>cwnd</code>的大小达到这个值，将转换到拥塞避免模式；</li></ul> <p><strong>三种模式要相互转换</strong></p> <p>例如初始cwnd=1 ssthresh=16</p> <ol><li><p>慢启动</p> <p>每传一次数据cwnd指数增长：2、4、8、16</p> <p>当cwnd=ssthresh=16的时候就变成拥塞避免</p></li> <li><p>拥塞避免</p> <p>这个时候每传一次数据cwnd+1，线性增长，当cwnd=24的时候如果一直没有接收到回应那可以认为发送拥塞了就会超时重传，这个时候</p> <p>ssthresh=cwnd/2=12，cwnd=1重新开始慢启动算法，然后当cwnd=ssthresh=12的时候又开始拥塞避免</p> <p>然后假如当cwnd=16的时候，接受到了同一个报文三次重复确认，但是也许并没有发生拥塞所以就启动快重传</p></li> <li><p>快重传-快速恢复：重传数据时就更新ssthresh=当前cwnd/2=8，而cwnd更新为ssthresh 的值==8，然后开始拥塞避免阶段</p></li></ol> <blockquote><p><code>慢启动</code>算法思想：当主机开始发送数据时，由于并不清楚网络的负荷情况，如果立即把大量数据字节注入到网络，那么就有可能引起网络发生拥塞，所以由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值，试探一下网络的拥塞情况。慢开始规定，在发送方每收到一个新的报文段的确认后，拥塞窗口的值就增大1，刚开始我们先设置拥塞窗口值为1，发送方收到一个新的确认报文之后，cwnd变为2，发送方接收到两个新的确认报文之后cwnd加2变成。即拥塞窗口的增长每次都是收到确认报文段数量的2倍。为了防止拥塞窗口增长多大引起网络阻塞，为其设置了一个慢启动门限，当到达门限时，就进入到拥塞避免阶段</p></blockquote> <blockquote><p><code>拥塞避免</code>算法的思路：不再以指数形式增长拥塞窗口，而是每经过一个往返时间RTT就将发送方的拥塞窗口+1，使其增长缓慢，按照线性方式增长，如果发生网络拥塞，比如丢包时，就将慢启动门限设为原来的一半，然后将拥塞窗口设置为1，开始执行慢启动算法。</p></blockquote> <blockquote><p><code>快速重传</code>算法思想：快速重传要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。快速重传规定，发送方只要一连接收到3个重复确认，就知道接收方确实没有收到该报文段，因而应当立即进行重传，这样就不会出现超时，发送方也就不会误认为出现了网络拥塞。使用快速重传可以使整个网络的吞吐量提高约20%。快速重传后进入快速恢复。</p></blockquote> <blockquote><p><code>快速恢复</code>的思想：将慢启动门限值设置为原来的一半，然后将拥塞窗口设置为现在的慢启动的门限值，不再执行慢启动而是直接进入拥塞避免阶段。使发送窗口成线性方式增长。【也有的快速恢复实现是把快速恢复时的拥塞窗口cwnd值再增大一些（即3个报文段长度），即等于新的门限值+3个报文段长度。这样做的理由是，既然发送方收到3个重复的确认，就表明3个分组已经离开了网络。这3个分组不再消耗网络的资源，而是停留在接收方的缓冲区种（接收方发送出了3个重复确认就证明了这个事实）。可见现在网络中并不是堆积了分组，而是减少了3个分组。因此可以适当的把拥塞窗口扩大些】</p></blockquote> <p>快速重传的图解：</p> <p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220318200423011.png" alt="image-20220318200423011"></p> <h3 id="_8-arp是地址解析协议-简单解释下工作原理"><a href="#_8-arp是地址解析协议-简单解释下工作原理" class="header-anchor">#</a> 8.ARP是地址解析协议，简单解释下工作原理</h3> <ol><li>首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</li> <li>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。</li> <li>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写F:\project\my\my-notes\docs.vuepress\config\themeConfig.js入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</li> <li>源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</li></ol> <h3 id="_9-icmp协议"><a href="#_9-icmp协议" class="header-anchor">#</a> 9.ICMP协议</h3> <blockquote><p>ICMP是Internet Control Message Protocol，因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由器是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。ICMP报文有两种：差错报告报文和询问报文。</p></blockquote> <h3 id="_10-dhcp协议"><a href="#_10-dhcp协议" class="header-anchor">#</a> 10.DHCP协议</h3> <blockquote><p>动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。通常被应用在大型的局域网络环境中，主要作用是集中的管理、分配IP地址，使网络环境中的主机动态的获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率。</p></blockquote> <h3 id="_11-ttl是什么-作用是什么-哪些工具会用到它"><a href="#_11-ttl是什么-作用是什么-哪些工具会用到它" class="header-anchor">#</a> 11.TTL是什么？作用是什么？哪些工具会用到它?</h3> <blockquote><p>TTL是指生存时间，简单来说，它表示了数据包在网络中的时间，经过一个路由器后TTL就减一，这样TTL最终会减为0，当TTL为0时，则将数据包丢弃，这样也就是因为两个路由器之间可能形成环，如果没有TTL的限制，则数据包将会在这个环上一直死转，由于有了TTL，最终TTL为0后，则将数据包丢弃。</p> <p>使用TTL：</p> <ul><li>ping发送数据包里面有TTL，但是并非是必须的，即是没有TTL也是能正常工作的</li> <li>traceroute正是因为有了TTL才能正常工作</li> <li>ifconfig是用来配置网卡信息的，不需要TTL</li> <li>netstat是用来显示路由表的，也是不需要TTL的</li></ul></blockquote> <h3 id="_12-web页面的请求过程"><a href="#_12-web页面的请求过程" class="header-anchor">#</a> 12.web页面的请求过程</h3> <ul><li><a href="##web-%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AF%B7%E6%B1%82%E5%8E%86%E7%A8%8B">Web 页面的请求历程</a> <ul><li><a href="###%E6%9F%A5%E6%89%BE-dns-%E7%BC%93%E5%AD%98">查找 DNS 缓存</a></li> <li><a href="#%E5%8F%91%E8%B5%B7-dns-%E6%9F%A5%E8%AF%A2">发起 DNS 查询</a></li> <li><a href="#arp-%E8%AF%B7%E6%B1%82">ARP 请求</a></li> <li><a href="#%E5%B0%81%E8%A3%85-tcp-%E6%95%B0%E6%8D%AE%E5%8C%85">封装 TCP 数据包</a></li> <li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E7%9B%AE%E6%A0%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5">浏览器与目标服务器建立 TCP 连接</a></li> <li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E9%80%81-http-%E8%AF%B7%E6%B1%82%E5%88%B0-web-%E6%9C%8D%E5%8A%A1%E5%99%A8">浏览器发送 HTTP 请求到 web 服务器</a></li> <li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%B9%B6%E5%8F%91%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%93%8D%E5%BA%94">服务器处理请求并发回一个响应</a></li> <li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E5%9B%9E%E4%B8%80%E4%B8%AA-http-%E5%93%8D%E5%BA%94">服务器发送回一个 HTTP 响应</a></li> <li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA-html-%E7%9A%84%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9">浏览器显示 HTML 的相关内容</a></li></ul></li></ul> <p><img src="https://z3.ax1x.com/2021/03/30/cPRJrF.png" alt=""></p> <p>Hey guys 各位读者姥爷们大家好，这里是程序员 cxuan 计算机网络连载系列的第 13 篇文章。</p> <p>到现在为止，我们算是把应用层、运输层、网络层和数据链路层都介绍完了，那么现在是时候把这些内容都串起来，做一个全面的回顾了。那么我这就以 Web 页面的请求历程为例，来和你聊聊计算机网络中这些协议是怎样工作的、数据包是怎么收发的，从输入 URL 、敲击会车到最终完成页面呈现在你面前的这个过程。</p> <p>首先，我打开了 Web Browser ，然后在 Google 浏览器 URL 地址栏中输入了 <code>maps.google.com</code>。</p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/cPcwPP.png" alt=""></p> <p>然后 ......</p> <h4 id="_12-1-查找-dns-缓存"><a href="#_12-1-查找-dns-缓存" class="header-anchor">#</a> 12.1 查找 DNS 缓存</h4> <p>浏览器在这个阶段会检查四个地方是否存在缓存，第一个地方是浏览器缓存，这个缓存就是 DNS 记录。</p> <p>浏览器会为你访问过的网站在固定期限内维护 DNS 记录。因此，它是第一个运行 DNS 查询的地方。 浏览器首先会检查这个网址在浏览器中是否有一条对应的 DNS 记录，用来找到目标网址的 IP 地址。</p> <p>我是 chrome 浏览器，所以在 mac 中，无法使用 <strong>chrome://net-internals/#dns</strong> 找到对应的 IP 地址，在 windows 中是可以找到的。</p> <blockquote><p>那么 mac 怎么查询 DNS 记录呢？你可以使用 <code>nslookup</code> 命令来查找，但这不是我们讨论的重点。</p></blockquote> <p><code>DNS(Domain Name System)</code> 是一个分布式的数据库，它用于维护网址 URL 到其 IP 地址的映射关系。在互联网中，IP 地址是计算机所能够理解的一种地址，而 DNS 的这种别名地址是我们人类能够理解和记忆的地址，DNS 就负责把人类记忆的地址映射成计算机能够理解的地址，每个 URL 都有唯一的 IP 地址进行对应。</p> <p>举个例子，google 的官网是 www.google.com ，而 google 的 ip 地址是 216.58.200.228 ，这两个地址你在 URL 上输入哪个都能访问，但是 IP 地址不好记忆，而 google.com 简单明了。DNS 就相当于是我们几年前使用的家庭电话薄，比如你想给 cxuan 打电话，你有可能记不住 cxuan 的电话号码，此时你需要查询电话薄来找到 cxuan 的电话号码。</p> <p>浏览器第二个需要检查的地方就是<strong>操作系统缓存</strong>。如果 DNS 记录不在浏览器缓存中，那么浏览器将对操作系统发起系统调用，Windows 下就是 <code>getHostName</code>。</p> <blockquote><p>在 Linux 和大部分 UNIX 系统上，除非安装了 <code>nscd</code>，否则操作系统可能没有 DNS 缓存。</p> <p>nscd 是 Linux 系统上的一种<strong>名称服务缓存程序</strong>。</p></blockquote> <p>浏览低第三个需要检查的地方是<strong>路由器缓存</strong>，如果 DNS 记录不在自己电脑上的话，浏览器就会和与之相连的路由器共同维护 DNS 记录。</p> <p>如果与之相连的路由器也没有 DNS 记录的话，浏览器就会检查 <code>ISP</code> 中是否有缓存。ISP 缓存就是你本地通信服务商的缓存，因为 ISP 维护着自己的 DNS 服务器，它缓存 DNS 记录的本质也是为了降低请求时间，达到快速响应的效果。一旦你访问过某些网站，你的 ISP 可能就会缓存这些页面，以便下次快速访问。对于经常看小电影的你是否感到震惊呢？如果家里还安装了一个可以联网的摄像头的话，那就有点嗨皮了。</p> <blockquote><p>你肯定比较困惑为什么第一步浏览器需要检查这么多缓存，你可能会感到不舒服，因为缓存可能会透露我们的隐私，但是这些缓存在调节网络流量和缩短数据传输时间等方面至关重要。</p></blockquote> <p>所以，上面涉及到 DNS 缓存的查询过程如下。</p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/cPc08f.png" alt=""></p> <p>如果上面四个步骤中都不存在 DNS 记录，那么就表示不存在 DNS 缓存，这个时候就需要发起 DNS 查询，以查找目标网址（本示例中是 maps.google.com）的 IP 地址。</p> <h4 id="_12-2-发起-dns-查询"><a href="#_12-2-发起-dns-查询" class="header-anchor">#</a> 12.2 发起 DNS 查询</h4> <p>如上所述，如果想要使我的计算机和 maps.google.com 建立连接并进行通信的话，我需要知道 maps.google.com 的 IP 地址，由于 DNS 的设计原因，本地 DNS 可能无法给我提供正确的 IP 地址，那么它就需要在互联网上搜索多个 DNS 服务器，来找到网站的正确 IP 地址。</p> <blockquote><p>这里有个疑问，为什么我需要搜索多个 DNS 服务器的来找到网站的 IP 地址呢？一台服务器不行吗？</p></blockquote> <p>因为 DNS 是分布式域名服务器，每台服务器只维护一部分 IP 地址到网络地址的映射，没有任何一台服务器能够维持全部的映射关系。</p> <p>在 DNS 的早期设计中只有一台 DNS 服务器。这台服务器会包含所有的 DNS 映射。这是一种<code>集中式</code>的设计，这种设计并不适用于当今的互联网，因为互联网有着<strong>数量巨大并且持续增长</strong>的主机，这种集中式的设计会存在以下几个问题</p> <ul><li><code>单点故障(a single point of failure)</code>，如果 DNS 服务器崩溃，那么整个网络随之瘫痪。</li> <li><code>通信容量(traaffic volume)</code>，单个 DNS 服务器不得不处理所有的 DNS 查询，这种查询级别可能是上百万上千万级，一台服务器很难满足。</li> <li><code>远距离集中式数据库(distant centralized database)</code>，单个 DNS 服务器不可能 <code>邻近</code> 所有的用户，假设在美国的 DNS 服务器不可能临近让澳大利亚的查询使用，其中查询请求势必会经过低速和拥堵的链路，造成严重的时延。</li> <li><code>维护(maintenance)</code>，维护成本巨大，而且还需要频繁更新。</li></ul> <p>所以在当今网络情况下 DNS 不可能集中式设计，因为它完全没有可扩展能力，所以采用<code>分布式设计</code>，这种设计的特点如下</p> <p><strong>分布式、层次数据库</strong>。</p> <p>首先分布式设计首先解决的问题就是 DNS 服务器的扩展性问题，因此 DNS 使用了大量的 DNS 服务器，它们的组织模式一般是层次方式，并且分布在全世界范围内。<strong>没有一台 DNS 服务器能够拥有因特网上所有主机的映射</strong>。相反，这些映射分布在所有的 DNS 服务器上。</p> <p>大致来说有三种 DNS 服务器：<code>根 DNS 服务器</code>、 <code>顶级域(Top-Level Domain, TLD) DNS 服务器</code> 和 <code>权威 DNS 服务器</code> 。这些服务器的层次模型如下图所示</p> <p><img src="https://z3.ax1x.com/2021/03/30/cPca5t.png" alt=""></p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/cPcUUI.png" alt=""></p> <ul><li><code>根 DNS 服务器</code> ，有 400 多个根域名服务器遍及全世界，这些根域名服务器由 13 个不同的组织管理。根域名服务器的清单和组织机构可以在 https://root-servers.org/ 中找到，根域名服务器提供 TLD 服务器的 IP 地址。</li> <li><code>顶级域 DNS 服务器</code>，对于每个顶级域名比如 com、org、net、edu 和 gov 和所有的国家级域名 uk、fr、ca 和 jp 都有 TLD 服务器或服务器集群。所有的顶级域列表参见 https://tld-list.com/ 。TDL 服务器提供了权威 DNS 服务器的 IP 地址。</li> <li><code>权威 DNS 服务器</code>，在因特网上具有公共可访问的主机，如 Web 服务器和邮件服务器，这些主机的组织机构必须提供可供访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。一个组织机构的权威 DNS 服务器收藏了这些 DNS 记录。</li></ul> <p>在了解了 DNS 服务器的设计理念之后，我们回到 DNS 查找的步骤上来，DNS 的查询方式主要分为三种</p> <p>DNS 查找中会出现三种类型的查询。通过组合使用这些查询，<strong>优化的 DNS 解析过程可缩短传输距离</strong>。在理想情况下，可以使用缓存的记录数据，从而使 DNS 域名服务器能够直接使用非递归查询。</p> <ul><li><code>递归查询</code>：在递归查询中，DNS 客户端要求 DNS 服务器（一般为 DNS 递归解析器）将使用所请求的资源记录响应客户端，或者如果解析器无法找到该记录，则返回错误消息。</li></ul> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203062015844.png" alt=""></p> <ul><li><code>迭代查询</code>：在迭代查询中，如果所查询的 DNS 服务器与查询名称不匹配，则其将返回对较低级别域名空间具有权威性的 DNS 服务器的引用。然后，DNS 客户端将对引用地址进行查询。此过程继续使用查询链中的其他 DNS 服务器，直至发生错误或超时为止。</li></ul> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/cPcYbd.png" alt=""></p> <ul><li><code>非递归查询</code>：当 DNS 解析器客户端查询 DNS 服务器以获取其有权访问的记录时通常会进行此查询，因为其对该记录具有权威性，或者该记录存在于其缓存内。DNS 服务器通常会缓存 DNS 记录，查询到来后能够直接返回缓存结果，以防止更多带宽消耗和上游服务器上的负载。</li></ul> <p>上面负责开始 DNS 查找的介质就是 <strong>DNS 解析器</strong>，它一般是 ISP 维护的 DNS 服务器，它的主要职责就是通过向网络中其他 DNS 服务器询问正确的 IP 地址。</p> <p>如果想要了解更多关于 DNS 的消息，请查阅 <a href="https://mp.weixin.qq.com/s?__biz=MzI0ODk2NDIyMQ==&amp;mid=2247487880&amp;idx=1&amp;sn=fd38ce30ae82fa7d08e5f83fabb9d497&amp;chksm=e999e49adeee6d8c1adacbfe27dc59097e4cb9d39c6a04802b0fe61877653330e75721cbde0b&amp;token=1399988516&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">万字长文爆肝 DNS 协议！<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>所以对于 maps.google.com 这个域名来说，如果 ISP 维护的服务器没有 DNS 缓存记录，它就会向 DNS 根服务器地址发起查询，根名称服务器会将其重定向到 .com 顶级域名服务器。 .com 顶级域名服务器会将其重定向到google.com 权威服务器。google.com 名称服务器将在其 DNS 记录中找到 maps.google.com 匹配的 IP 地址，并将其返回给您的 DNS 解析器，然后将其发送回你的浏览器。</p> <p>这里值得注意的是，DNS 查询报文会经过许多路由器和设备才会达到根域名等服务器，每经过一个设备或者路由器都会使用<code>路由表</code> 来确定哪种路径是数据包达到目的地最快的选择。这里面涉及到路由选择算法，如果小伙伴们想要了解路由选择算法，可以看看这篇文章 https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/13753-25.html#anc3</p> <h4 id="_12-3-arp-请求"><a href="#_12-3-arp-请求" class="header-anchor">#</a> 12.3 ARP 请求</h4> <p>我看了很多篇文章都没有提到这一点，那就是 ARP 请求的这个过程。</p> <blockquote><p>什么时候需要发送 ARP 请求呢？</p></blockquote> <p>这里其实有个前提条件</p> <ul><li>如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP 查询</li> <li>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询</li></ul> <p>ARP 协议的全称是 <code>Address Resolution Protocol(地址解析协议)</code>，它是一个通过<strong>用于实现从 IP 地址到 MAC 地址的映射，即询问目标 IP 对应的 MAC 地址</strong> 的一种协议。</p> <p>简而言之，ARP 就是一种解决地址问题的协议，它以 IP 地址为线索，定位下一个应该接收数据分包的主机 MAC 地址。如果目标主机不在同一个链路上，那么会查找下一跳路由器的 MAC 地址。</p> <blockquote><p>关于为什么有了 IP 地址，还要有 MAC 地址概述可以参看知乎这个回答 https://www.zhihu.com/question/21546408</p></blockquote> <p>ARP 的大致工作流程如下</p> <p>假设 A 和 B 位于同一链路，不需要经过路由器的转换，主机 A 向主机 B 发送一个 IP 分组，主机 A 的地址是 192.168.1.2 ，主机 B 的地址是 192.168.1.3，它们都不知道对方的 MAC 地址是啥，主机 C 和 主机 D 是同一链路的其他主机。</p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203062015029.png" alt=""></p> <p>主机 A 想要获取主机 B 的 MAC 地址，通过主机 A 会通过<code>广播</code> 的方式向以太网上的所有主机发送一个 <code>ARP 请求包</code>，这个 ARP 请求包中包含了主机 A 想要知道的主机 B 的 IP 地址的 MAC 地址。</p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203062015158.png" alt=""></p> <p>主机 A 发送的 ARP 请求包会被同一链路上的所有主机/路由器接收并进行解析。每个主机/路由器都会检查 ARP 请求包中的信息，如果 ARP 请求包中的<code>目标 IP 地址</code> 和自己的相同，就会将自己主机的 MAC 地址写入响应包返回主机 A</p> <p><img src="https://z3.ax1x.com/2021/03/30/cPcJDH.png" alt=""></p> <p>由此，可以通过 ARP 从 IP 地址获取 MAC 地址，实现同一链路内的通信。</p> <p>所以，要想发送 ARP 广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。</p> <p>这里会涉及到 <strong>ARP 缓存</strong>的概念。</p> <p>现在你知道了发送一次 IP 分组前通过发送一次 ARP 请求就能够确定 MAC 地址。那么是不是每发送一次都得经过广播 -&gt; 封装 ARP 响应 -&gt; 返回给主机这一系列流程呢？</p> <p>想想看，浏览器是如何做的？浏览器内置了缓存能够缓存你最近经常使用的地址，那么 ARP 也是一样的。ARP 高效运行的关键就是维护每个主机和路由器上的 <code>ARP 缓存(或表)</code>。这个缓存维护着每个 IP 到 MAC 地址的映射关系。通过把第一次 ARP 获取到的 MAC 地址作为 IP 对 MAC 的映射关系到一个 ARP 缓存表中，下一次再向这个地址发送数据报时就不再需要重新发送 ARP 请求了，而是直接使用这个缓存表中的 MAC 地址进行数据报的发送。每发送一次 ARP 请求，缓存表中对应的映射关系都会被清除。</p> <p>通过 ARP 缓存，降低了网络流量的使用，在一定程度上防止了 ARP 的大量广播。</p> <p><img src="https://z3.ax1x.com/2021/03/30/cPc1gO.png" alt=""></p> <p>一般来说，发送过一次 ARP 请求后，再次发送相同请求的几率比较大，因此使用 ARP 缓存能够减少 ARP 包的发送，除此之外，不仅仅 ARP 请求的发送方能够缓存 ARP 接收方的 MAC 地址，接收方也能够缓存 ARP 请求方的 IP 和 MAC 地址，如下所示</p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/cPcl8K.png" alt=""></p> <p>不过，<strong>MAC 地址的缓存有一定期限，超过这个期限后，缓存的内容会被清除</strong>。</p> <p>深入理解 ARP 协议的话，可以参考 cxuan 的这篇文章。</p> <p><a href="https://mp.weixin.qq.com/s?__biz=MzI0ODk2NDIyMQ==&amp;mid=2247487804&amp;idx=1&amp;sn=f001a24a308053b3723dfb12d36045ee&amp;chksm=e999e42edeee6d383fbb411792e22e4028bb8c2441255786f50cf848443af7b1bd5e382078dc&amp;token=1623097963&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">ARP，这个隐匿在计网背后的男人<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <hr> <p>所以，浏览器会首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC。</p> <p>如果缓存没有命中：</p> <ul><li>查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。</li> <li>查询选择的网络接口的 MAC 地址</li> <li>我们发送一个数据链路层的 ARP 请求：</li></ul> <p><img src="https://z3.ax1x.com/2021/03/30/cPcK4x.png" alt=""></p> <p>根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：</p> <p>直连：</p> <ul><li>如果我们和路由器是直接连接的，路由器会返回一个 <code>ARP Reply</code> （见下面）。</li></ul> <p>集线器：</p> <ul><li>如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也连接在其中，它会返回一个 <code>ARP Reply</code> 。</li></ul> <p>交换机：</p> <ul><li>如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。</li> <li>如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 ARP 请求</li> <li>如果路由器也<code>连接</code>在其中，它会返回一个 <code>ARP Reply</code></li></ul> <p><code>ARP Reply</code>:</p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203062015460.png" alt=""></p> <p>现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了：</p> <ul><li>使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议</li> <li>如果本地/ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回。</li></ul> <p>（上述均来自：https://github.com/skyline75489/what-happens-when-zh_CN#dns）</p> <hr> <h4 id="_12-4-封装-tcp-数据包"><a href="#_12-4-封装-tcp-数据包" class="header-anchor">#</a> 12.4 封装 TCP 数据包</h4> <p>浏览器得到目标服务器的 IP 地址后，根据 URL 中的端口可以知道端口号 （http 协议默认端口号是 80， https 默认端口号是 443），会准备 TCP 数据包。数据包的封装会经过下面的层层处理，数据到达目标主机后，目标主机会解析数据包，完整的请求和解析过程如下。</p> <p><img src="https://gitee.com/hnistzdk/picture/raw/master/images/202203062015367.png" alt=""></p> <p>这里就不再详细介绍了，读者朋友们可以阅读 cxuan 的这篇文章 <a href="https://mp.weixin.qq.com/s?__biz=MzI0ODk2NDIyMQ==&amp;mid=2247486408&amp;idx=1&amp;sn=c332ae7ae448f3eb98865003ecade589&amp;chksm=e999fedadeee77cc6281d1b170bd906b58220d6cd83054bc741821f4167f1f18ceee9ba0e449&amp;token=1623097963&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">TCP/IP 基础知识详解<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>详细了解。</p> <h4 id="_12-5-浏览器与目标服务器建立-tcp-连接"><a href="#_12-5-浏览器与目标服务器建立-tcp-连接" class="header-anchor">#</a> 12.5 浏览器与目标服务器建立 TCP 连接</h4> <p>在经过上述 DNS 和 ARP 查找流程后，浏览器就会收到一个目标服务器的 IP 和 MAC地址，然后浏览器将会和目标服务器建立连接来传输信息。这里可以使用很多种 Internet 协议，但是 HTTP 协议建立连接所使用的运输层协议是 TCP 协议。所以这一步骤是浏览器与目标服务器建立 TCP 连接的过程。</p> <p>TCP 的连接建立需要经过 TCP/IP 的三次握手，三次握手的过程其实就是浏览器和服务器交换 SYN 同步和 ACK 确认消息的过程。</p> <p>假设图中左端是客户端主机，右端是服务端主机，一开始，两端都处于<code>CLOSED（关闭）</code>状态。</p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203062015575.png" alt=""></p> <ol><li>服务端进程准备好接收来自外部的 TCP 连接。然后服务端进程处于 <code>LISTEN</code> 状态，等待客户端连接请求。</li> <li>客户端向服务器发出连接请求，请求中首部同步位 SYN = 1，同时选择一个初始序号 sequence ，简写 seq = x。SYN 报文段不允许携带数据，只消耗一个序号。此时，客户端进入 <code>SYN-SEND</code> 状态。</li> <li>服务器收到客户端连接后，，需要确认客户端的报文段。在确认报文段中，把 SYN 和 ACK 位都置为 1 。确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。此时，TCP 服务器进入 <code>SYN-RECEIVED(同步收到)</code> 状态。</li> <li>客户端在收到服务器发出的响应后，还需要给出确认连接。确认连接中的 ACK 置为 1 ，序号为 seq = x + 1，确认号为 ack = y + 1。TCP 规定，这个报文段可以携带数据也可以不携带数据，如果不携带数据，那么下一个数据报文段的序号仍是 seq = x + 1。这时，客户端进入 <code>ESTABLISHED (已连接)</code> 状态</li> <li>服务器收到客户的确认后，也进入 <code>ESTABLISHED</code> 状态。</li></ol> <p>这样三次握手建立连接的阶段就完成了，双方可以直接通信了。</p> <h4 id="_12-6-浏览器发送-http-请求到-web-服务器"><a href="#_12-6-浏览器发送-http-请求到-web-服务器" class="header-anchor">#</a> 12.6 浏览器发送 HTTP 请求到 web 服务器</h4> <p>一旦 TCP 连接建立完成后，就开始直接传输数据办正事了！此时浏览器会发送 <code>GET</code> 请求，要求目标服务器提供 maps.google.com 的网页，如果你填写的是表单，则发起的是 <code>POST</code> 请求，在 HTTP 中，GET 请求和 POST 请求是最常见的两种请求，基本上占据了所有 HTTP 请求的九成以上。</p> <p>除了请求类型外，HTTP 请求还包含很多很多信息，最常见的有 Host、Connection 、User-agent、Accept-language 等</p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203062015796.png" alt=""></p> <p>首先 Host 表示的是对象所在的主机。<code>Connection: close</code> 表示的是浏览器需要告诉服务器使用的是<code>非持久连接</code>。它要求服务器在发送完响应的对象后就关闭连接。<code>User-agent</code>: 这是请求头用来告诉 Web 服务器，浏览器使用的类型是 <code>Mozilla/5.0</code>，即 Firefox 浏览器。<code>Accept-language</code> 告诉 Web 服务器，浏览器想要得到对象的法语版本，前提是服务器需要支持法语类型，否则将会发送服务器的默认版本。下面我们针对主要的实体字段进行介绍（具体的可以参考 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers MDN 官网学习）</p> <p>HTTP 的请求标头分为四种： <code>通用标头</code>、<code>请求标头</code>、<code>响应标头</code> 和 <code>实体标头</code>。</p> <p>这四种标头又分别有很多内容，如果你想要深入理解一下关于 HTTP 请求头的相关内容，可以参考 cxuan 的这篇文章</p> <p><a href="https://mp.weixin.qq.com/s?__biz=MzkwMDE1MzkwNQ==&amp;mid=2247496023&amp;idx=1&amp;sn=7281feaf0853d5465d7b082329b7f2d7&amp;chksm=c04ae609f73d6f1f2bac28a3222f83ce24ef199e9869e887aa23f627f194d9d9cb43e1683ddb&amp;token=1307572136&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">深入理解 HTTP 标头<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h4 id="_12-7-服务器处理请求并发回一个响应"><a href="#_12-7-服务器处理请求并发回一个响应" class="header-anchor">#</a> 12.7 服务器处理请求并发回一个响应</h4> <p>这个服务器包含一个 Web 服务器，也就是 Apache 服务器，服务器会从浏览器接收请求并将其传递给请求处理程序并生成响应。</p> <blockquote><p>请求处理程序也是一个程序，它一般是用 .net 、php、ruby 等语言编写，用于读取请求，检查请求内容，cookie，必要时更新服务器上的信息的这么一个程序。它会以特定的格式比如 JSON、XML、HTML 组合响应。</p></blockquote> <h4 id="_12-8-服务器发送回一个-http-响应"><a href="#_12-8-服务器发送回一个-http-响应" class="header-anchor">#</a> 12.8 服务器发送回一个 HTTP 响应</h4> <p>服务器响应包含你请求的网页以及状态代码，压缩类型（Content-Encoding），如何缓存页面（Cache-Control），要设置的 cookie，隐私信息等。</p> <p>比如下面就是一个响应体</p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203062015075.png" alt=""></p> <p>关于深入理解 HTTP 请求和响应，可以参考这篇文章</p> <p><a href="https://mp.weixin.qq.com/s?__biz=MzkwMDE1MzkwNQ==&amp;mid=2247496030&amp;idx=1&amp;sn=82f56874f82f372af71e23a8e385f8cd&amp;chksm=c04ae600f73d6f16d707c1d32b00e3f0d47e893c9cf59a2eb60ace418943aeb5c5c679cb27ea&amp;token=1307572136&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">看完这篇HTTP，跟面试官扯皮就没问题了<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h4 id="_12-9-浏览器显示-html-的相关内容"><a href="#_12-9-浏览器显示-html-的相关内容" class="header-anchor">#</a> 12.9 浏览器显示 HTML 的相关内容</h4> <p>浏览器会分阶段显示 HTML 内容。 首先，它将渲染裸露的 HTML 骨架。 然后它将检查 HTML 标记并发送 GET 请求以获取网页上的其他元素，例如图像，CSS 样式表，JavaScript 文件等。这些静态文件由浏览器缓存，因此你再次访问该页面时，不用重新再请求一次。最后，您会看到 maps.google.com 显示的内容出现在你的浏览器中。</p> <h3 id="_13-dns-domain-name-system"><a href="#_13-dns-domain-name-system" class="header-anchor">#</a> 13.DNS(Domain Name System)</h3> <blockquote><p>当我们在浏览器的地址栏输入域名时，用户主机会首先在自己的DNS高速缓存中查找该域名所对应的IP地址，如果没有找到，则会向网络中的某台DNS服务器中有域名和IP地址映射关系的数据库，当DNS服务器收到DNS查询报文后，在其数据库中进行查询，之后将查询结果发送给用户主机，主机中的浏览器就可以通过web服务器的IP地址对其进行访问了</p></blockquote> <h4 id="_13-1概要"><a href="#_13-1概要" class="header-anchor">#</a> 13.1概要</h4> <ul><li><p>因特网采用<code>层次树状结构的域名结构</code></p></li> <li><p>域名的结构由若干个分量组成，各分量之间用&quot;点&quot;隔开，分别代表不同级别的域名</p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203141011347.png" alt="image-20220314101111303"></p> <ul><li>每一级的域名都由英文字母和数字组成，不超过63个字符，不区分大小写字母</li> <li>级别最低的域名写在最左边，而级别最高的顶级域名写在最右边</li> <li>完整的域名不超过255个字符</li></ul></li> <li><p>域名系统既不规定一个域名需要包含多少个夏季域名，也不规定每一级的域名代表什么意思</p></li> <li><p>各级域名由其上一级的域名管理结构管理，而最高的顶级域名则由因特网名与数字地址分配机构ICANN进行管理。</p></li></ul> <h4 id="_13-2域名结构"><a href="#_13-2域名结构" class="header-anchor">#</a> 13.2域名结构：</h4> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203141016645.png" alt="image-20220314101646534"></p> <h4 id="_13-3域名空间"><a href="#_13-3域名空间" class="header-anchor">#</a> 13.3域名空间：</h4> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203141018070.png" alt="image-20220314101835963"></p> <h4 id="_13-4域名划分"><a href="#_13-4域名划分" class="header-anchor">#</a> 13.4域名划分</h4> <ul><li><p>域名和IP地址的映射关系必须保存在域名服务器中，供所有其他应用查询。显然不能将所有信息都储存在一台域名服务器中。DNS使用分布在各地的域名服务器来实现域名到IP地址的转换。</p></li> <li><p>域名服务器可以划分为以下四种不同的类型：</p> <ul><li><p><strong>根域名服务器</strong></p> <blockquote><p>根域名服务器是最高层次的域名服务器。每个根域名服务器都知道所有的顶级域名服务器的域名及其IP地址。因特网上共有13个不同IP地址的根域名服务器。尽管我们将这13个根域名服务器中的每一个都视为单个的服务器，但“每台服务器”实际上是由许多分布在世界各地的计算机构成的服务器群集。当本地域名服务器向根域名服务器发出查询请求时，路由器就把查询请求报文转发到离这个DNS客户最近的一个根域名服务器。这就加快了DNS的查询过程，同时也更合理地利用了因特网的资源。<code>根域名服务器通常并不直接对城名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的IP地址</code>。</p></blockquote></li> <li><p><strong>顶级域名服务器</strong></p> <blockquote><p>这些域名服务器负责<code>管理在该顶级域名服务器注册的所有二级域名</code>。当收到DNS查询请求时就给出相应的回答（(可能是最后的结果，也可能是下一级权限域名服务器的IP地址)。</p></blockquote></li> <li><p><strong>权限域名服务器</strong></p> <blockquote><p>这些域名服务器负责<code>管理某个区</code>的域名。每一个主机的域名都必须在某个权限域名服务器处注册登记。因此权限域名服务器知道其管辖的域名与IP地址的映射关系。另外，权限域名服务器还知道其下级域名服务器的地址。</p></blockquote></li> <li><p><strong>本地域名服务器</strong></p> <blockquote><p>本地域名服务器不属于上述的域名服务器的等级结构。当一个主机发出DNS请求报文时，这个报文就首先被送往该主机的本地域名服务器。<code>本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中</code>。每一个因特网服务提供者ISP，一个大学，甚至一个大学里的学院，都可以拥有一个本地域名服务器，它有时也称为<code>默认域名服务器</code>。本地域名服务器离用户较近，一般不超过几个路由器的距离，也有可能就在同一个局域网中。本地域名服务器的IP地址需要直接配置在需要域名解析的主机中。</p></blockquote></li></ul></li></ul> <h4 id="_13-5域名解析的过程"><a href="#_13-5域名解析的过程" class="header-anchor">#</a> 13.5域名解析的过程</h4> <ol><li><p>递归查询</p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203141027220.png" alt="image-20220314102730156"></p></li> <li><p>迭代查询</p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203141028194.png" alt="image-20220314102851109"></p></li></ol> <blockquote><p>为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了高速缓存。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p></blockquote> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203141029667.png" alt="image-20220314102950580"></p> <blockquote><p>由于域名到IP地址的映射关系并不是永久不变，为保持告诉缓存中的内容正确，域名服务器<code>应为每项内容设置计时器并删除超过合理时间的项</code>(例如，每个项目只存放两天)</p></blockquote> <blockquote><p>不但在本地域名服务器中需要高速缓存，在用户主机中也很需要。许多用户主机在启动时从本地域名服务器下载域名和IP地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到域名时才向域名服务器查询。同理，主机也需要保持高速缓存中内容的正确性。</p></blockquote> <h2 id="http和https"><a href="#http和https" class="header-anchor">#</a> HTTP和HTTPS</h2> <h3 id="_1-http和https的基本概念和区别"><a href="#_1-http和https的基本概念和区别" class="header-anchor">#</a> 1.HTTP和HTTPS的基本概念和区别</h3> <p>http的中文叫做超文本传输协议,它负责完成客户端到服务端的一系列操作,是专门用来传输注入HTML的超媒体文档等web内容的协议,它是基于传输层的TCP协议的应用层协议</p> <p>https:https是基于安全套接字的http协议,也可以理解为是http+ssl/tls(数字证书)的组合</p> <p>http和https的区别:</p> <ul><li>HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头</li> <li>HTTP 是不安全的，而 HTTPS 是安全的</li> <li>HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443</li> <li>在 OSI 网络模型中，HTTPS的加密是在传输层完成的,因为SSL是位于传输层的,TLS的前身是SSL,所以同理</li> <li>HTTP无需认证证书,而https需要认证证书</li></ul> <blockquote><p>小结：简单来说http是用来进行html等超媒体传输的,但是http不安全,为了安全,使用证书SSL和HTTP的方式进行数据传输,也就是HTTPS</p></blockquote> <h3 id="_2-http"><a href="#_2-http" class="header-anchor">#</a> 2.HTTP</h3> <h4 id="_2-1-http协议的组成"><a href="#_2-1-http协议的组成" class="header-anchor">#</a> 2.1 HTTP协议的组成</h4> <p>请求报文包含三部分：</p> <ul><li>请求行：包含请求方法、URI、HTTP版本信息</li> <li>请求首部字段</li> <li>请求内容实体</li></ul> <p>响应报文包含三部分：</p> <ul><li>状态行：包含HTTP版本、状态码、状态码的原因短语</li> <li>响应首部字段</li> <li>响应内容实体</li></ul> <h4 id="_2-2-说一下http协议中302状态-阿里经常问"><a href="#_2-2-说一下http协议中302状态-阿里经常问" class="header-anchor">#</a> 2.2 说一下HTTP协议中302状态(阿里经常问)</h4> <ul><li>http协议中，返回状态码302表示重定向。</li> <li>这种情况下，服务器返回的头部信息中会包含一个 Location 字段，内容是重定向到的url。</li></ul> <h4 id="_2-3-http1-0-1-1-2-0之间的区别和特性"><a href="#_2-3-http1-0-1-1-2-0之间的区别和特性" class="header-anchor">#</a> 2.3 HTTP1.0，1.1,2.0之间的区别和特性</h4> <p>==<strong>http1.0</strong>:==</p> <ul><li>是一种无状态、无连接的应用层协议,每个请求都会新创建一个tcp连接,完成后关闭服务端不跟踪也不记录过去的请求(无状态),但正因频繁创建连接,由于tcp的慢启动(为了不给网络造成拥堵,在首次进行tcp请求的时候,会限制服务端和客户端之间交互数据量的上限,大概为14kb,之后以指数级增长),服务端接受请求,处理完,发送完响应之后就会将tcp连接关闭,这造成了很大的资源浪费,而且http1.0在一个请求接收到响应之后才会接着发送下一个,这也造成了head of line blocking(队头阻塞),现在的浏览器为了解决这个问题,采用了一个页面可以建立多个tcp连接的方式来进行</li></ul> <p>==http1.1:==</p> <ul><li><p>继承了http1.0的特点,同时改善了http的一些问题,首先是长连接,http1.1新增加了connecion字段,里面可以设置keey-Alive(保持连接)或者close(关闭长连接),避免了每次请求都会新建连接,提高了网络的利用率</p></li> <li><p>http1.1还增加了Host字段,用来明确表示浏览器要服务器上的哪一个WEB站点,这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点,同时还支持了断点续传</p></li> <li><p>http1.1的管道:可以发送很多请求到服务端,但是服务端必须要按顺序返回响应,由此可以看出http1.1的管道只是把客户端的请求序列变成了服务端的响应序列,还是有问题,很多浏览器并不是很支持</p></li> <li><p>http1.1还增加了缓存,断点续传</p></li></ul> <p>==http2.0 :==</p> <ul><li><p>采用了二进制分帧(frame),在应用层和传输层之间增加了一个二进制分帧层,也就是把http1.x的header和body使用帧(frame)进行了封装</p> <ul><li>这里明确几个概念:流(stream) : 已经建立上连接的双向字节流(也就是一个请求和其对应的响应) 消息:与逻辑消息对应的完整的一系列数据帧 帧(frame):http2.0进行通信的最小单位,每个帧都会包含一个头部,这个头部会包含当前帧所处的流</li></ul></li> <li><p>多路复用:所有的HTTP2.0通信都在一个TCP连接上完成，这个连接可以承载任意数量的双向数据流,每个数据流都以消息的方式进行发送,这个发送可以使乱序的,然后在通过每个帧头部的流标识符进行组装,同时每个数据流都可以设置优先级,可见http2.0真正实现了并行发送数据,这个是给予二进制分帧来实现的,接下来上一张图片,展示一下一个在一个流中分帧传输的实例</p> <p><img src="https://gitee.com/hnistzdk/picture/raw/master/images/202203151644495.jpeg" alt="img"></p></li> <li><p>头部压缩:就是和服务端约定头部的数据的编码,来将头部进行压缩后发送,这样就可以增加请求头的容量</p></li></ul> <h4 id="_2-4-get与post的区别"><a href="#_2-4-get与post的区别" class="header-anchor">#</a> 2.4 get与post的区别</h4> <p>区别一：</p> <ul><li>get重点在从服务器上获取资源。</li> <li>post重点在向服务器发送数据。</li></ul> <p>区别二：</p> <ul><li>get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用&quot;?&quot;连接，多个请求数据间用&quot;&amp;&quot;连接，如http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的。</li> <li>post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的。</li></ul> <p>区别三：</p> <ul><li>Get传输的数据量小，因为受URL长度限制，但效率较高。</li> <li>Post可以传输大量数据，所以上传文件时只能用Post方式。</li></ul> <p>区别四：</p> <ul><li>get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等。</li> <li>post较get安全性较高。</li></ul> <p>区别五：</p> <ul><li>get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。</li> <li>post支持标准字符集，可以正确传递中文字符。</li></ul> <h4 id="_2-5-请求头中一般有什么"><a href="#_2-5-请求头中一般有什么" class="header-anchor">#</a> 2.5 请求头中一般有什么</h4> <p>1）Accept 作用： 浏览器端可以接受的媒体类型 例：Accept ：text/html</p> <p>2）Accept-Encoding： 作用： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）</p> <p>3）Accept-Language 作用： 浏览器申明自己接收的语言。 例：Accept-Language: en-us</p> <p>4）Connection 例如：　Connection: keep-alive  当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p> <p>5）Host（发送请求时，该报头域是必需的） 作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的</p> <p>6）Referer 作用：当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的</p> <p>7）User-Agent 作用：告诉HTTP服务器， 客户端使用的<a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="noopener noreferrer">操作系统<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和浏览器的名称和版本</p> <h4 id="_2-6-请求和响应常见通用头"><a href="#_2-6-请求和响应常见通用头" class="header-anchor">#</a> 2.6 请求和响应常见通用头</h4> <p><img src="https://gitee.com/hnistzdk/picture/raw/master/images/202203152018395.png" alt="img"></p> <h4 id="_2-6-1-content-type"><a href="#_2-6-1-content-type" class="header-anchor">#</a> 2.6.1 Content-Type</h4> <blockquote><p>Content-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件。</p></blockquote> <p>常见的媒体格式类型如下：</p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203152019731.png" alt="img"></p> <p>以application开头的媒体格式类型：</p> <p><img src="https://gitee.com/hnistzdk/picture/raw/master/images/202203152020238.png" alt="img"></p> <h3 id="二、一次完整的http请求发生了什么"><a href="#二、一次完整的http请求发生了什么" class="header-anchor">#</a> 二、一次完整的http请求发生了什么</h3> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203151649807.png" alt="image-20220315164958769"></p> <p>1.域名解析</p> <blockquote><p>首先浏览器会解析域名（准确的叫法应该是主机名）得到对应的IP地址，那怎么解析到对应的IP地址？
① 浏览器会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有该域名对应的条目，而且没有过期，如果有且没有过期则解析到此结束；
② 如果浏览器自身的缓存里面没有找到对应的条目，那么浏览器会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束；
③ 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功；
④ 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），然后进一步请求；
正常情况下通过这四步基本就能解析域名获得IP了；</p></blockquote> <h4 id="_2-发起tcp三次握手"><a href="#_2-发起tcp三次握手" class="header-anchor">#</a> 2.发起TCP三次握手</h4> <blockquote><p>拿到域名对应的IP地址之后，User-Agent（一般是指浏览器）会以一个随机端口（1024 &lt; 端口 &lt; 65535）向服务器的WEB程序的80端口发起TCP的连接请求。这个连接请求（原始的http请求经过TCP/IP4层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。</p> <h6 id="为什么http协议要基于tcp来实现"><a href="#为什么http协议要基于tcp来实现" class="header-anchor">#</a> 为什么HTTP协议要基于TCP来实现？</h6> <p>目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。</p></blockquote> <h4 id="_3-建立连接后发起http请求"><a href="#_3-建立连接后发起http请求" class="header-anchor">#</a> 3.建立连接后发起HTTP请求</h4> <blockquote><p>进过TCP3次握手之后，浏览器发起了http的请求</p> <p><strong>HTTP请求报文格式（HTTP请求报文由3部分组成（请求行+请求头+请求体））</strong></p> <p><img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/202203151659198.jpeg" alt="在这里插入图片描述"></p> <h6 id="请求行"><a href="#请求行" class="header-anchor">#</a> 请求行：</h6> <p>①是请求方法，GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。
②为请求对应的URL地址，它和报文头的Host属性组成完整的请求URL。
③是协议名称及版本号。</p> <h6 id="请求头"><a href="#请求头" class="header-anchor">#</a> 请求头：</h6> <p>④是HTTP的报文头，报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。
与缓存相关的规则信息，均包含在header中</p> <h6 id="请求体"><a href="#请求体" class="header-anchor">#</a> 请求体：</h6> <p>⑤是报文体，它将一个页面表单中的组件值通过param1=value1¶m2=value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据。不但报文体可以传递请求参数，请求URL也可以通过类似于“/chapter15/user.html?param1=value1¶m2=value2”的方式传递请求参数。</p> <h6 id="什么是url、uri、urn"><a href="#什么是url、uri、urn" class="header-anchor">#</a> 什么是URL、URI、URN？</h6> <p>URI ：Uniform Resource Identifier 统一资源标识符
URL：Uniform Resource Locator 统一资源定位符
URN： Uniform Resource Name 统一资源名称
URL和URN 都属于 URI</p></blockquote> <h4 id="_4-服务器响应http请求-浏览器得到html"><a href="#_4-服务器响应http请求-浏览器得到html" class="header-anchor">#</a> 4.服务器响应HTTP请求，浏览器得到HTML</h4> <blockquote><p>服务器端WEB程序接收到http请求以后，就开始处理该请求，处理之后就返回给浏览器html文件</p></blockquote> <p>一些常见的HTTP状态码</p> <table><thead><tr><th>状态码</th> <th>描述</th></tr></thead> <tbody><tr><td>200 OK</td> <td>表示从客户端发送给服务器的请求被正常处理并返回</td></tr> <tr><td>204 No Content</td> <td>表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）</td></tr> <tr><td>206 Patial Content</td> <td>表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容</td></tr> <tr><td>301 Moved Permanently</td> <td>永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL</td></tr> <tr><td>302  Found</td> <td>临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）</td></tr> <tr><td>303 See Other</td> <td>表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源；302与303的区别：后者明确表示客户端应当采用GET方式获取资源</td></tr> <tr><td>304  Not Modified</td> <td>表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码</td></tr> <tr><td>307 Temporary Redirect</td> <td>临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）</td></tr> <tr><td>400 Bad Request</td> <td>表示请求报文中存在语法错误</td></tr> <tr><td>401 Unauthorized</td> <td>未经许可，需要通过HTTP认证</td></tr> <tr><td>403 Forbidden</td> <td>服务器拒绝该次访问（访问权限出现问题）</td></tr> <tr><td>404 Not Found</td> <td>表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用</td></tr> <tr><td>500 Inter Server Error</td> <td>表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时</td></tr> <tr><td>503 Server Unavailable</td> <td>表示服务器暂时处于超负载或正在进行停机维护，无法处理请求</td></tr></tbody></table> <h4 id="_5-浏览器解析html代码-并请求代码中的资源-如果js、css、图片等"><a href="#_5-浏览器解析html代码-并请求代码中的资源-如果js、css、图片等" class="header-anchor">#</a> 5.浏览器解析HTML代码，并请求代码中的资源(如果js、css、图片等)</h4> <blockquote><p>浏览器拿到html文件后，就开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以请求成功显示的顺序并不一定是代码里面的顺序。
浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。</p></blockquote> <h4 id="_6-浏览器对页面进行渲染呈现给用户"><a href="#_6-浏览器对页面进行渲染呈现给用户" class="header-anchor">#</a> 6.浏览器对页面进行渲染呈现给用户</h4> <blockquote><p>浏览器利用自己内部的工作机制，把请求到的静态资源和html代码进行渲染，渲染之后呈现给用户。</p></blockquote> <h4 id="_7-关闭tcp连接"><a href="#_7-关闭tcp连接" class="header-anchor">#</a> 7.关闭TCP连接</h4> <blockquote><p>这一步不是所有的网页都会这么做，例如网页版微信就没有关闭 TCP 连接，因为微信上别人可以随时发消息给你，实际上别人先把消息发送到了微信服务器，微信服务器再通过 TCP 链接，把消息推送到你的屏幕上。</p> <p>试想一下，如果网页版微信关闭了 TCP 连接会怎样？</p> <p>结果是：你不刷新网页，就永远收不到消息了。同时，如果你频繁的发消息给别人，那么就在频繁的创建连接，关闭连接，这是很消耗资源的。所以微信就干脆不关闭 TCP 连接，这样微信服务器就可以给我们的浏览器发消息。</p> <p>一次Http请求报文头部信息，其中 Connection: keep-alive 意味着这次请求结束后不会关闭 TCP 连接。</p> <p>当然不是所有的 HTTP 请求都没有关闭连接，例如一篇博文，浏览器收到数据显示就可以了，没有那么多动态数据，我看完就关了，这时就应该关闭 TCP 连接，当然这还是取决于请求的服务器。说了这么多，还没说关闭连接。</p> <p>关闭 TCP 连接专业点说叫做“四次挥手”，与 TCP 建立连接的“三次握手”相对应。</p> <p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个TCP连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭</p></blockquote> <h3 id="https"><a href="#https" class="header-anchor">#</a> HTTPS</h3> <h4 id="https的工作原理"><a href="#https的工作原理" class="header-anchor">#</a> HTTPS的工作原理</h4> <ul><li>首先服务端给客户端传输证书,这个证书就是公钥,只是包含了很多的信息,比如说证书的办法机构,证书的过期时间</li> <li>客户端进行证书的解析,比如说验证办法机构,过期时间,如果发现没有任何问题,就生成一个随机值(私钥),然后用证书对这个私钥进行加密,并发送给服务端</li> <li>服务端使用私钥将这个信息进行解密,得到客户端的私钥,然后客户端和服务端就可以通过这个私钥进行通信了</li> <li>服务端将消息进行对称加密(简单来说就是讲消息和私钥进行混合,除非知道私钥否则服务进行解密),私钥正好只有客户端和服务端知道,所以信息就比较安全了</li> <li>服务端将进行对称加密后的消息进行传送</li> <li>客户端使用私钥进行信息的解密</li></ul> <ol><li>TCP/IP协议体系的认知</li> <li>链路层
<ol><li>以太网帧的格式</li> <li>MTU的概念</li> <li>ARP协议和RARP协议（掌握一下ARP缓存的原理）</li></ol></li> <li>网络层
<ol><li>掌握IP的首部格式</li> <li>掌握IP的分片</li> <li>掌握IP选路</li> <li>ICMP协议
<ol><li>掌握报文格式</li> <li>分类：查询 + 差错</li> <li>两种 + 五种</li></ol></li></ol></li> <li>传输层
<ol><li>UDP，次要一点，掌握特点和首部各个字段</li> <li>掌握TCP
<ol><li>特点 + 首部字段 + 可靠机制</li> <li>连接控制 ： 三次握手，四次挥手，同时打开，同时关闭，半关闭（可能问到为什么需要）</li> <li>流量控制机制：滑动窗口,慢启动，拥塞避免，快速重传，快速恢复</li> <li>超时重传机制：各种定时器</li></ol></li></ol></li> <li>应用层
<ol><li>掌握DNS协议
<ol><li>名字空间</li> <li>指针查询（反向查找或逆向解析）基本原理</li> <li>DNS缓存</li></ol></li> <li>FTP协议（活化石）：
<ol><li>控制流和数据流</li> <li>两种工作模式： PASV 和 PORT</li> <li>各种指令和响应码</li> <li>断点续传和匿名FTP的概念</li></ol></li> <li>HTTP协议：
<ol><li>报文格式：请求报文，响应报文，请求头各种字段，响应头各种字段</li> <li>HTTP状态码</li></ol></li> <li>HTTPS协议
<ol><li>握手的详细过程</li> <li>摘要算法，数字签名，数字证书的原理和过程</li></ol></li></ol></li></ol></div> <footer class="page-edit" style="display:none;"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">3/19/2022, 10:46:15 PM</span></div></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><canvas id="vuepress-canvas-cursor"></canvas><canvas id="vuepress-canvas-ribbon"></canvas><APlayer audio="" fixed="true" mini="true" autoplay="autoplay" theme="#f9bcdd" loop="loop" order="random" preload="auto" volume="0.1" mutex="true" lrc-type="3" list-max-height="250" storage-name="vuepress-plugin-meting" id="aplayer-fixed"></APlayer></div></div>
    <script src="/my_blog/assets/js/app.c3dec6d6.js" defer></script><script src="/my_blog/assets/js/3.3346af26.js" defer></script><script src="/my_blog/assets/js/1.d09d735b.js" defer></script><script src="/my_blog/assets/js/120.cf9e7347.js" defer></script>
  </body>
</html>
